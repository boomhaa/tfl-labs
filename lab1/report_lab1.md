# Лабораторная работа №1

## Задание

По имеющейся SRS определить:

- Завершимость
- конечность классов эквивалентности по НФ. Если их конечное число, то построить минимальную систему переписывания им
  соответствующую.
- локальную конфлюэнтность и пополняемость по Кнуту-Бендиксу

### Начальная SRS

```text
cb -> ba
aaa -> aa
aba -> ba
ac -> cc
baa -> ba
bba -> ba
bbb -> b
bbc -> c
bcc -> cc
ba -> cab
cac -> cc
bab -> cac
ccc -> c
babb -> ba
babc -> ε
baca -> cabba
caab -> bb
caac -> bc
aabcaa -> a
```

---

## 1) Завершимость

Докажем незавершимость исходной SRS. В данном случае существует цикл, который не позволяет в конечном итоге прийти к
нормальной форме.

```text
caba -> (aba -> ba) -> cba -> (cb -> ba) -> baa -> (ba -> cab) -> caba -> ...
```

---

## 2) Конечность

Введем в нашу систему фундированный порядок (армейский), то есть переорентируем правила так, чтобы rule_left >
rule_right (сначала смотрим на длину, потом сравниваем лексиграфически, т.е. c > b > a)

```text
переорентированная система

cb -> ba
aaa -> aa
aba -> ba
cc -> ac
baa -> ba
bba -> ba
bbb -> b
bbc -> c
bcc -> cc
cab -> ba
cac -> cc
cac -> bab
ccc -> c
babb -> ba
babc -> ε
cabba -> baca
caab -> bb
caac -> bc
aabcaa -> a
```

Докажем конечность SRS при помощи построения дерева. Возмем в качестве корневой вершины ε и будем дописывать a|b|c.
Послностью построив дерево можно увидеть, что на границе в итоге остаются только те слова, которые можно переписать (
красные вершины). А так как при переписывании слов новые слова будут либо подниваться выше по дереву, либо оставаться на
то же уровне, то в конечном итоге оно придет к нормальной форме (зеленой вершине). В общей сложности получилось 31
нормальная форма
![Рис. 1. Порождающее дерево](graph/graph.svg)

---

## 3) Локальная конфлюэнтность и пополняемость по Кнуту-Бендиксу

### 3.1) Локальная конфлюэнтность

Докажем что в данной SRS нет локальной конфлюэнтности. Для этого найдем пример, который это доказывает.

Возьмем слово `aabcaaa` и перепишем его:

- по правилу `aabcaa -> a`: `aabcaaa -> aa`
- по правилу `aaa -> aa`: `aabcaaa -> aabcaa`

Переписывая дальше вторую ветку мы получаем `aabcaa -> a`. Получается, что две разные ветки переписывания дают нам две
разные НФ `a` и `aa`. Соотвестсвенно система локально не конфлюэнтна.

### 3.2) Пополняемость (с ε-правилом)

Так как в начальной системе существует незамыкаемый цикл, в ней отсутствует пополняемость. Поэтому переопределим правила
в таком же порядке, в каком использовали во пункте 2).

Прогоним нашу систему через программу `rules_additioner.rs`. Получим примерно такую систему:

```text
cb -> ba
aaa -> aa
aba -> ba
cc -> ac
baa -> ba
bba -> ba
bbb -> b
bbc -> c
bac -> ac
cab -> ba
cac -> ac
bab -> ac
aac -> c
c -> .
ba -> aa
aab -> bb
b -> a
aa -> a
a -> .
```

Минимизировав полученную систему мы получим:

```text
a -> .
b -> .
c -> .
```

где `.` - это `ε`

### 3.3) Пополняемость (без ε-правила)

Уберем ε-правило из начальной системы и заново прогоним через программу `rules_additioner.rs`. Получим систему:

```text
cb -> ba
aaa -> aa
aba -> ba
cc -> ac
baa -> ba
bba -> ba
bbb -> b
bac -> ac
cab -> ba
cac -> ac
bab -> ac
caab -> bb
bc -> ac
ac -> c
ca -> ba
ba -> a
aa -> a
ab -> c
c -> a
bb -> a
b -> a
```

Минимизировав полученную систему мы получим:

```text
b -> a
c -> a
```

## 4) Тестирование

Так как в при пополнении изначальной системы, она становится тривиальной и соответственно инварианты также тривиальны. Поэтому были найдены инварианты на дополненой системе без ε-правила.

### 4.1) Инвариант M

Зададим гомоморфизм
```math
M : \{a,b,c\}^* \to D_2(\mathbb{R}_{>0})
```
в моноид диагональных матриц 2 × 2 над положительными вещественными числами, заданный на буквах:
```math
M(a) =
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}, \quad
M(b) =
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}, \quad
M(c) =
\begin{pmatrix}
\alpha & 0 \\
0 & 1
\end{pmatrix}, \quad
\alpha > 1.
```

и продолжающийся на слова мультипликативно:
```math
M(uv) = M(u)\,M(v), \qquad M(\varepsilon) = I.
```

Тогда для слова w матрица M(w) имеет 
```math
\det M(w)=\alpha^{\#c(w)}
```

### Свойства

Для слова 
```math
w \in \{ a, b, c \}^* $$
``` 

```math
M(w) =
\begin{pmatrix}
\alpha^{\#c(w)} & 0 \\
0 & 1
\end{pmatrix},
\qquad
\det M(w) = \alpha^{\#c(w)}.
```

Здесь `#c(w)` обозначает количество вхождений буквы `c` в слове `w`.

Таким образом, детерминант матрицы `M(w)` напрямую зависит от числа символов `c` в слове.

### Интерпретация
Инвариант `det M(w)` отражает **вес** слова по количеству букв `c`  

| Условие     | Значение инварианта        | Интерпретация               |
| ----------- |----------------------------| --------------------------- |
| `#c(w) = 0` | `det M(w) = 1`             | В слове нет букв `c`        |
| `#c(w) > 0` | `det M(w) = α^{#c(w)} > 1` | Есть хотя бы одна `c`       |
| Шаг `c → a` | `det M` строго уменьшается | Прогресс к нормальной форме |

Таким образом, `det M(w)` служит монотонным инвариантом (моноинвариантом).

### 4.2) Взвешенная Парих-мера

#### Определение:
```math
$$
(\Phi(w)=\#a+\#b+2\cdot\#c).
$$
```

#### Замечание. 

Это конкретный представитель семейства

```math
(\Phi_{(w_a,w_b,w_c)}=w_a\#a+w_b\#b+w_c\#c) \ с \ (w_b\ge w_a) \ и \ (w_c\ge w_b)

```

При выборе 
```math 
(w_a, w_b, w_c) = (1, 1, 2)
``` 
получаем используемую здесь меру.

#### Свойства

- Для всех правил системы значение `Φ(w)` не увеличивается.
- Правила, где `c` заменяется на `a` или `b`, уменьшают `Φ`,
так как вес `c` больше.
- Таким образом, при каждом применении таких правил мера строго убывает,
а в остальных случаях остаётся неизменной.

